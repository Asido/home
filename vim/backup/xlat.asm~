;	Description:
;		Translation table using XLAT instruction
;
;	Build:
;		nasm -f elf -g -F stabs xlat.asm
;		ld -o xlat xlat.o

SECTION .data
	StatMsg: db "Processing...", 10		; 10 = EOL ; 0 = EOF
	StatLen: equ $-StatMsg
	DoneMsg: db "...Done!", 10
	DoneLen: equ $-DoneMsg

	; The following translation table translates all lowercase characters to
	; uppercase. It also translates all non-printable characters to spaces,
	; except for LF and HT.
	UpCase:
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x09, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f
	db 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f
	db 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
	db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f
	db 0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
	db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x5f
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	
	; The following translation table is "stock" in that it translates all
	; printable characters as themselves, and converts all non-printable
	; characters to spaces except for LF and HT. You can modify this to
	; translate anything you want to any character you want.
	Custom:
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x09, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f
	db 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f
	db 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
	db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f
	db 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
	db 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20


	SECTION .bss
		READLEN equ 1024			; Length of buffer
		ReadBuffer: resb READLEN	; Text buffer itself

	SECTION .text
		global _start

		_start:
			nop					; To keep GDB happy

			; Display the "I'm working ..." message via stderr:
			mov eax, 4			; Specify sys_write call
			mov ebx, 2			; Specify File Descriptor 2: Standard Error
			mov ecx, StatMsg	; Pass offset of the message
			mov edx, StatLen	; Pass the length of the message
			int 0x80			; Make kernel call

		;Read a buffer full of text from stdin:
		read:
			mov eax, 3			; Specify sys_read call
			mov ebx, 0			; Specify File Descriptor 3: Standard Input
			mov ecx, ReadBuffer	; Pass offset of the buffer to read to
			mov edx, READLEN	; Pass the number of bytes to read at one pass
			int 0x80			; Make kernel call
			mov ebp, eax		; Copy sys_read return value for safe-keeping
			cmp eax, 0			; If eax = 0, sys_read reached EOF
			je done				; Jump If Equal (to 0, from compare)

			; Set up the registers for the translate step:
			mov ebx, UpCase		; Place the offset of the table into ebx
			mov edx, ReadBuffer	; Place the offset of the buffer into edx
			mov ecx, ebp		; Place the number of bytes in the buffer into ecx

		; Use the XLAT instruction to translate the data in the buffer:
		; (Note: the commented out instructions do the same work as XLAT;
		; un-comment them and then comment out XLAT to try it!
		translate:
			; xor eax, eax				; Clear high 24 bits of eax
			mov al, byte [edx+ecx]		; Load character into AL for translation
			; mov al, byte [UpCase+eax]	; Translate character in AL via table
			xlat						; Translate character in AL via table
			mov byte [edx+ecx], al		; Put the translated char back in the buffer
			dec ecx						; Decrement character count
			jnz translate				; If there are more chars in the buffer, repeat

		; Write the buffer full of translated text to stdout:
		write:
			mov eax, 4			; Specify sys_write call
			mov ebx, 1			; Specify File Descriptor 1: Standard Output
			mov ecx, ReadBuffer	; Pass offset of the buffer
			mov edx, ebp		; Pass the # of bytes of data in the buffer
			int 0x80			; Make kernel call
			jmp read			; Loop back and load another buffer full

		; Display the "I'm done" message via stderr:
		done:
			mov eax, 4			; Specify sys_write call
			mov ebx, 2			; Specify File Descriptor 2: Standard Error
			mov ecx, DoneMsg	; Pass offset of the message
			mov edx, DoneLen	; Pass the length of the message
			int 0x80			; Make kernel call

			; All done! Clean exit:
			mov eax, 1			; Code for Exit syscall
			mov ebx, 0			; Return a code of zero
			int 0x80			; Make kernel call
