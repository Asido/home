#ifndef GUARD_link_list_h

#define GUARD_link_list_h

template <class T>
struct Node {
	public:
		Node():
			link(0) {}
		Node(const Node* l, const T& d):
			link(l), data(d) {}

		T& get_data() { return data; }
		void set_data(const T& v) { data = v; }
		Node* get_link() { return link; }
		void set_link(Node* l) { link = l; }

	private:
		Node* link;
		T data;
};

template <class T>
class Link_list {
public:
	typedef T* iterator;
	typedef const T* const_iterator;
	typedef T value_type;
	typedef size_t size_type;

	// CONSTRUCTOR / DESTRUCTOR
	Link_list () { init(); }
	virtual ~Link_list () {}

	// operators
	T* iterator.operator++() { return next(); }

	// methods to manage the collection
	void push_back(const T&);
	iterator begin() { return first; }
	iterator end() { return last; }
	bool empty() { return first == 0; }

private:
	Node<T>* node;
	iterator first;
	iterator last;
	
	// private methods
	void init();
	T* next();
};

template <class T>
void Link_list<T>::init() {
	first = last = 0;
}

template <class T>
void Link_list<T>::push_back(const T& v) {
	Node<T> *n = new Node<T>;
	n->set_data(v);
	n->set_link(node);
	node = n;
	if(!empty())
		last = &(node->get_data());
	else
		first = last = &(node->get_data());
}

template <class T>
T* Link_list<T>::next() {
	node = node.get_link();
	return node.get_data();
}

#endif /* end of include guard: GUARD_link_list_h */
