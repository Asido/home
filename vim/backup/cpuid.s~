#cpuid.s Sample program to extract the processor Vendor ID
.section .data	# A section for data elements that are declared with an initial value.
output:			# The label of the starting memory loc
	# Declares a string variable and placed in the memory location by the label 'output'ation.
	.ascii "The processor Vendor ID: 'xxxxxxxxxxxx'\n"
.section .text	# A section for instructions.
.globl _start	# '_start' is like main method/function in c/c++/java...
_start:
	nop		# Dummy instruction to avoid the bug in gdb, when it doesn't stop at '*_start' breakpoint.
	# NOP stands for - no operation.
	movl $0, %eax		# Loads EAX register with a value of zero.
	# EAX - accumulator for operands and results data.
	# The value defines the CPUID output option, which in this case is the Vendor ID string.
	cpuid				# Runs CPUID instruction
	movl $output, %edi	# Loads the memory location of the 'output' label into the EDI register.
	# EDI - data pointer for destination of string operations.
	# Below: after the CPUID instruction is run, you must collect the response that is divided
	# up between the three output registers - EBX, EDX, ECX.
	movl %ebx, -26(&edi)	# Places EBX value to the memory location pointed by EDI + 26 (first 'x')
	movl %edx, 30(%edi) # Now same with the EDX value. It replaces the xx... in the string variable.
	movl %ecx, 34(%edi) # And lastly ECX register. Each register holds 4 bytes of data.
	# When all of the Vendor ID string pieces are placed in memory, it's time to display it.kk
	movl $4, %eax		# System call value. (4 - 'write' system call)
	movl $1, %ebx		# The file descriptor to write to. (0 - stdin, 1 - stdout, 2 - stderr)
	movl $output, %ecx	# The start of the string.
	movl $40, %edx		# The length of the string.
	int $0x80			# Linux call to access the console display from the Linux kernel.
	# Linux kernel provides many preset functions that can be easily accessed from assembly apps.
	# To access those kernel functions, 'int' instruction code must be used,
	# which generates a software interrupt with the value of '0x80'.
	# The specific function that is performed is determined by the value of EAX register.
	# In other way, you would have to send each output caharacter yourself
	# to the proper I/O address of the display.
	# Linux system calls are a great time-saver when programming in assembler.
	movl $1, %eax		# Again a Linux system call value of 1. (1 - exit function)
	movl $0, %ebx		# The return value of an exit function.
	int $0x80			# Calls the kernel function. Equivalent to 'exit(0)' in C/C++
