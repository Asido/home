;	Description:
;		A little improved hex dump program which introduces assembly
;		language procedures.
;
;	Build:
;		nasm -f elf -g -F stabs hexdump.asm
;		ld -o hexdump hexdump.o
;

SECTION .bss				; Section containing uninitialized data

	BUFFLEN equ 10
	Buff resb BUFFLEN

SECTION .data				; Section containing initialized data

SECTION .text			; Section containing code

EXTERN ClearLine, DumpChar, PrintLine

GLOBAL _start

;----------------------------------------------------------------------------------------------------
;	MAIN PROGRAM BEGINS HERE
;----------------------------------------------------------------------------------------------------
_start:
	nop						; No-ops for GDB
	nop

	; Whatever initialization needs doing before the loop scan starts is here:
	xor esi, esi			; Clear total byte counter to 0

; Read a buffer full of text from stdin:
Read:
	mov eax, 3				; Specify sys_read call
	mov ebx, 0				; Specify File Descriptor 0: Standard Input
	mov ecx, Buff			; Pass offset of the buffer to read to
	mov edx, BUFFLEN		; Pass number of bytes to read at one pass
	int 0x80				; Call sys_read to fill the buffer
	mov ebp, eax			; Save # of bytes read from file for later
	cmp eax, 0				; If eax = 0, sys_read reached EOF on stdin
	je Done					; Jump If Equal (to 0, from compare)

	; Set up the registers for the process buffer step:
	xor ecx, ecx			; Clear buffer pointer to 0

; Go through the buffer and convert binary byte values to hex digits:
Scan:
	xor eax, eax			; Clear EAX to 0
	mov al, byte [Buff+ecx]	; Get a byte from the buffer into AL
	mov edx, esi			; Copy total counter into EDX
	and edx, 0x0000000f		; Mask out lowest 4 bits of char counter
	call DumpChar			; Call the char poke procedure

	; Bump the buffer pointer to the next character and see if buffer's done:
	inc esi					; Increment total chars processed counter
	inc ecx					; Increment buffer pointer
	cmp ecx, ebp			; Compare with # of chars in buffer
	jae Read				; If we've done the buffer, go get more

	; See if we're at the end of a block of 16 and need to display a line:
	test esi, 0x0000000f	; Test 4 lowest bits in counter for 0
	jnz Scan				; If counter is *NOT* modulo 16, loop back
	call PrintLine			; ...otherwise print the line
	call ClearLine			; Clear hex dump line to 0's
	jmp Scan				; Continue scanning the buffer

; All done! Clean exit:
Done:
	call PrintLine			; Print the "leftovers" line
	mov eax, 1				; Code for Exit syscall
	mov ebx, 0				; Return a code of zero
	int 0x80				; Make kernel call



;----------------------------------------------------------------------------------------------------
; LoadBuff:		Fills a buffer with data from stdin via INT 0x80 sys_read
; UPDATED:		2011/02/18
; IN:			Nothing
; RETURNS:		# of bytes read in EBP
; MODIFIES:		ECX, EBP, Buff
; CALLS:		Kernel sys_write
; DESCRIPTION:	Loads a buffer full of data (BUFFLEN bytes) from stdin
;				using INT 0x80 sys_read and places it in Buff. Buffer
;				offset counter ECX is zeroed, because we're starting in
;				on a new buffer full of data. Caller must test value in
;				EBP: If EBP contains zero on return, we hit EOF on stdin.
;				Less than 0 in EBP on return indicates some kind of error.

LoadBuff:
	push eax			; Save caller's EAX
	push ebx			; Save caller's EBX
	push edx			; Save caller's EDX
	mov eax, 3			; Specify sys_read call
	mov ebx, 0			; Specify File Descriptor 0: Standard Input
	mov ecx, Buff		; Pass offset of the buffer to read to
	mov edx, BUFFLEN	; Pass number of bytes to read at one pass
	int 0x80			; Call sys_read to fill the buffer
	mov ebp, eax		; Save # of bytes read from file for later
	xor ecx, ecx		; Clear buffer pointer ECX to 0
	pop edx				; Restore caller's EDX
	pop ebx				; Restore caller's EBX
	pop eax				; Restore caller's EAX
	ret


