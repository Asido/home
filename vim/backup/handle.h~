#ifndef HANDLE_GEH1HA55
#define HANDLE_GEH1HA55

#include <stdexcept>

template <class T>
class Handle
{
	public:
		Handle(): p(0) {}
		Handle(const Handle& s): p(0) {
			if(s.p)	p = s.p->clone();
		}
		Handle& operator=(const Handle&);
		~Handle() { delete p; }

		Handle(T* t): p(t) {}

		operator bool() const { return p; }
		T& operator*() const;
		T* operator->() const;

	private:
		T* p;
};


template <class T>
Handle<T>& Handle<T>::operator=(const Handle& rhs)
{
	if(&rhs != this)
	{
		delete p;
		p = rhs.p ? rhs.p->clone() : 0;
	}
	return *this;
}

template <class T>
T& Handle<T>::operator*() const
{
	if(p)
		return *p;
	throw std::runtime_error("unbound Handle");
}

template <class T>
T* Handle<T>::operator->() const
{
	if(p)
		return p;
	throw std::runtime_error("unbound Handle");
}




template <class T> class Ref_handle
{
	public:
		// manage reference count as well as pointer
		Ref_handle(): refptr(new size_t(1)), p(0) {}
		Ref_handle(T* t): refptr(new size_t(1)), p(t) {}
		Ref_handle(const Ref_handle& h): refptr(h.refptr), p(h.p)
		{
			++*refptr;
		}

		Ref_handle& operator=(const Ref_handle&);
		~Ref_handle();

		// as before
		operator bool() const { return p; }
		T& operator*() const
		{
			if(p)
				return *p;
			throw std::runtime_error("unbound Ref_handle");
		}

		T* operator->() const
		{
			if(p)
				return p;
			throw std::runtime_error("unbound Ref_handle");
		}

	private:
		T* p;
		size_t* refptr;
};

template <class T>
Ref_handle<T>& Ref_handle<T>::operator=(const Ref_handle& rhs)
{
	++*rhs.refptr;
	// free the left-hand side, destroying pointers if appropiate
	if(--*refptr == 0)
	{
		delete refptr;
		delete p;
	}

	// copy in values from the right-hand side
	refptr = rhs.refptr;
	p = rhs.p;
	return *this;
}

template<class T> Ref_handle<T>::~Ref_handle()
{
	if(--*refptr == 0)
	{
		delete refptr;
		delete p;
	}
}

//=========================================================================


template <class T> class Ptr
{
	public:
		// new member to copy the object conditionally when needed
		void make_unique();

		// the rest of the class looks like Ref_handle except for its name
		Ptr(): refptr(new size_t(1)), p(0) {}
		Ptr(T* t): refptr(new size_t(1)), p(t) {}
		Ptr(const Ptr& h): refptr(h.refptr), p(h.p) { ++*refptr; }

		Ptr& operator=(const Ptr&);
		~Ptr();
		operator bool() const { return p; }
		T& operator*() const;
		T* operator->() const;

	private:
		T* p;
		size_t* refptr;
};


template <class T>
void Ptr<T>::make_unique()
{
	if(*refptr != 1)
	{
		--*refptr;
		refptr = new size_t(1);
		p = p ? clone(p) : 0;	// call the global (not member) version of clone
	}
}

template <class T> T* clone(const T* tp)
{
	return tp->clone();
}

// template<> std::vector<char>* clone(const std::vector<char>* vp)
// {
// 	return new std::vector<char>(*vp);
// }


template <class T>
Ptr<T>& Ptr<T>::operator=(const Ptr& rhs)
{
	++*rhs.refptr;
	// free the left-hand side, destroying pointers if appropiate
	if(--*refptr == 0)
	{
		delete refptr;
		delete p;
	}

	// copy in values from the right-hand side
	refptr = rhs.refptr;
	p = rhs.p;
	return *this;
}

template<class T> Ptr<T>::~Ptr()
{
	if(--*refptr == 0)
	{
		delete refptr;
		delete p;
	}
}

template<class T>
T& Ptr<T>::operator*() const
{
	if(p)
		return *p;
	throw std::runtime_error("unbound Ref_handle");
}

template<class T>
T* Ptr<T>::operator->() const
{
	if(p)
		return p;
	throw std::runtime_error("unbound Ref_handle");
}

#endif /* end of include guard: HANDLE_GEH1HA55 */
