; Description: Reads executable file environment variables.

SECTION .data
	
SECTION .bss
	
	MAXENV equ 50				; Maximum amount of environment variables to read
	EnvPtrs resd MAXENV			; It will hold the pointers to each env variable
	EnvLengths resd MAXENV		; It will hold the lengths of each env variable

SECTION .text

global _start

_start:
	
	nop							; To keep GDB happy

	call FillLengths			; Fill EnvLengths with max values
	
	mov ebp, esp				; Copy stack pointer to EBP
	mov ecx, [ebp]				; Move the amount of args to ECX
	lea ebp, [ebp+ecx*4+8]		; Calculate the first env variable address
	; mov edi, ebp				; Pass env variable address to EDI for SCASB instruction
	; xor eax, eax				; Make AL = 0 (this is what we are looking for with SCASB)
	; mov ecx, 0x0000ffff			; Limit search to 65535 bytes max
	; repne scasb					; Start to look for the end of the env variable
	; sub dword [EnvLengths], ecx	; Store the difference of how much ECX was decremented by SCASB

	; And now print that "env variable"
	mov eax, 4					; Specify sys_write call
	mov ebx, 1					; Specify File Descriptor 1: STDOUT
	; mov ecx, edi
	mov ecx, ebp
	mov edx, 2000
	int 0x80

	call Exit					; Clean exit

;---------------------------------------------------------------------------------------------------
; Fill EnvLengths with the maximum value - 65535 (0x0000ffff)

FillLengths:
	push ecx					; Save caller's registers
	push ebx
	mov ecx, MAXENV				; Pass ECX max env variable count (for LOOP)
	mov ebx, 0					; Offset of the EnvLengths
.repeat:
	mov dword [EnvLengths+ebx*4], 0x0000ffff	; Make the value
	inc ebx						; Increment to point to next value
	loop .repeat				; If ECX > 0, then repeat
	pop ebx						; Restore caller's registers
	pop ecx						
	ret

;----------------------------------------------------------------------------------------------------
; Clean exit of application with return value of 0

Exit:
	mov eax, 1					; Specify sys_exit call
	mov ebx, 0					; Specify return value of 0
	int 0x80					; Make kernel call
