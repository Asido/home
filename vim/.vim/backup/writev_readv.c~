#include <fcntl.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include "writev_readv.h"
#include "../../../source/lib/tlpi_hdr.h"

int main(int argc, char* argv[])
{
	int vec_size = 3;
	int i;

	struct iovec vecs[vec_size];
	for (i = 0; i < vec_size; ++i) {
		size_t size = rand() % 20;
		printf("allocating vecs[%d]: %d\n", i, size);
		vecs[i].iov_base = (char*)malloc(size);
		vecs[i].iov_len = size;
		srand(rand());
	}

	int fd = open("file", O_RDONLY);
	ssize_t read = readv(fd, vecs, vec_size);
	printf("read: %d\n", read);
	close(fd);

	fd = open("new_file", O_WRONLY | O_CREAT, S_IRWXU);
	ssize_t wrote = writev(fd, vecs, vec_size);
	printf("wrote: %d\n", wrote);
	close(fd);

	for (i = 0; i < vec_size; ++i)
		free(vecs[i].iov_base);
	
	exit(EXIT_SUCCESS);
}

ssize_t readv(int fd, const struct iovec *vector, int count)
{
	if (count < 0 || count > UIO_MAXIOV) {
		errno = EINVAL;
		return -1;
	}

	ssize_t total_read = 0;
	int i;
	for (i = 0; i < count; ++i) {
		ssize_t curr_read = read(fd, vector[i].iov_base, vector[i].iov_len);
		if (curr_read == 0)
			break;
		total_read += curr_read;
	}
	return total_read;
}

ssize_t writev(int fd, const struct iovec *vector, int count)
{
	if (count < 0 || count > UIO_MAXIOV) {
		errno = EINVAL;
		return -1;
	}

	ssize_t total_wrote = 0;
	int i = 0;
	for (i = 0; i < count; ++i) {
		ssize_t curr_wrote = write(fd, vector[i].iov_base, vector[i].iov_len);
		if (curr_wrote == 0)
			break;
		total_wrote += curr_wrote;
	}
	return total_wrote;
}
