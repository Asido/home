; This is like a normal program, but it still is in Ring 0.
; This loader is used to set up 32 bit mode and basic exception handling.
; It will be our 32 bit kernel
; Here is no 512 bytes limitation, so we can do anything we want!

[BITS 16]		; still in real mode
; From the memory map -- 0x500 through 0x7BFF in unused above the BIOS data area.
; We are loaded at 0x500 (0x50:0)
[ORG 0x500]

jmp MAIN

;------------------------------------
; Preprocessor directives
;------------------------------------
%include "stdio.inc"	; basic I/O routines
%include "gdt.inc"		; GDT routines
%include "a20.inc"		; routines to enable A20 address line
%include "fat12.inc"	; FAT12 driver. Kinda ;)
%include "common.inc"
%include "bootinfo.inc"
%include "memory.inc"

;--------------------
; DATA SECTION
;--------------------
LoadingMsg:	db "Searching for your shitty OS...",0x0
FailureMsg: db 0x0D, 0x0A, "*** FATAL: KERNEL is corrupt or not in the FLOPPY.IMG. Halting the system you check the image in the meantime.", 0x0D, 0x0A, 0x0A, 0x00

boot_info:
istruc multiboot_info
	at multiboot_info.flags,				dd 0
	at multiboot_info.memoryLo,				dd 0
	at multiboot_info.memoryHi,				dd 0
	at multiboot_info.bootDevice,			dd 0
	at multiboot_info.cmdLine,				dd 0
	at multiboot_info.mods_count,			dd 0
	at multiboot_info.mods_addr,			dd 0
	at multiboot_info.syms0,				dd 0
	at multiboot_info.syms1,				dd 0
	at multiboot_info.syms2,				dd 0
	at multiboot_info.mmap_length,			dd 0
	at multiboot_info.mmap_addr,			dd 0
	at multiboot_info.drives_length,		dd 0
	at multiboot_info.drives_addr,			dd 0
	at multiboot_info.config_table,			dd 0
	at multiboot_info.bootloader_name,		dd 0
	at multiboot_info.apm_table,			dd 0
	at multiboot_info.vbe_control_info,		dd 0
	at multiboot_info.vbe_mode_info,		dw 0
	at multiboot_info.vbe_interface_seg,	dw 0
	at multiboot_info.vbe_interface_off,	dw 0
	at multiboot_info.vbe_interface_len,	dw 0
iend

;---------------------------------------------------
; STAGE 2 LOADER ENTRY POINT
;	- Store BIOS information
;	- Load kernel
;	- Install GDT; go into protected mode (PMode)
;	- Jump to Stage 3
;---------------------------------------------------
MAIN:
	; setup segments and stack
	cli				; clear interrupts
	xor ax, ax		; null segments
	mov ds, ax
	mov es, ax
	mov ax, 0x9000	; stack begins at 0x9000-0xFFFF
	mov ss, ax
	mov sp, 0xFFFF
	sti				; enable interrupts

	mov [boot_info+multiboot_info.bootDevice], dl

	; install our GDT
	call INSTALL_GDT

	; enable A20
	call ENABLE_A20_KKBRD_OUT

	xor eax, eax
	xor ebx, ebx
	call BiosGetMemorySize64MB

	push eax
	mov eax, 64
	mul ebx
	mov ecx, eax
	pop eax
	add eax, ecx
	add eax, 1024

	mov dword [boot_info+multiboot_info.memoryHi], 0
	mov dword [boot_info+multiboot_info.memoryLo], eax

	mov eax, 0x0
	mov ds, ax
	mov di, 0x1000
	call BiosGetMemoryMap

	; print loading message
	mov si, LoadingMsg
	call PUTS16
	
	; initialize filesystem
	call LOAD_ROOT				; load root directory table

	; load kernel
	mov ebx, 0					; BX:BP points to buffer to load to
	mov ebp, IMAGE_RMODE_BASE	
	mov esi, ImageName			; our kernel file to load
	call LOAD_FILE				; load our file
	mov dword [ImageSize], ecx	; save size of kernel
	cmp ax, 0					; test for success
	je ENTER_STAGE3				; yep -- onto kernel!
	mov si, FailureMsg			; nope -- print error
	call PUTS16
	mov ah, 0
	int 0x16					; await keypress
	int 0x19					; warm boot computer
	cli							; if you get here, your PC is fucked up
	hlt



ENTER_STAGE3:
	; go into pmode
	cli				; clear interrupts
	mov eax, cr0	; set bit 0 in CR0 -- enter pmode
	or eax, 1
	mov cr0, eax

	jmp CODE_DESC:STAGE3	; far jump to fix CS. Code selector in GDT is 0x8!

	;*****************************************************************************************
	; NOTE: Do NOT re-enable interrupts! Doing so will tripple fault the CPU!
	; Fix this in STAGE3
	;*****************************************************************************************

;-------------------------------------------------------------------
;	ENTRY POINT FOR STAGE 3
;-------------------------------------------------------------------
[bits 32]				; Welcome to the 32 bit world!

%include "paging.inc"

BadImage db "*** FATAL: KERNEL is corrupt or bad format.",0

STAGE3:
	; set registers
	mov ax, DATA_DESC	; set data segments to data selectors (0x10)
	mov ds, ax
	mov ss, ax
	mov es, ax
	mov esp, 0x90000	; stack begins from 0x90000

	call CLR_SCR_32

	call ENABLE_PAGING

	; copy kernel to 1MB
	mov eax, dword [ImageSize]
	movzx ebx, word [bpbBytesPerSector]
	mul ebx
	mov ebx, 4
	div ebx
	cld
	mov esi, IMAGE_RMODE_BASE
	mov edi, IMAGE_PMODE_BASE
	mov ecx, eax
	rep movsd		 ; copy image to its protected mode address

	; test the image. if the format is ok, execute it
	; check signature
	mov ebx, IMAGE_PMODE_BASE
	mov esi, ebx
	mov edi, ImageSig
	cmpsd
	jne .bad_format
	; check data encoding
	add ebx, 5
	cmp ebx, 0
	jne EXECUTE		; all is ok, move to kernel execution!

.bad_format:
	mov ebx, BadImage
	call PUTS32
	jmp STOP

ImageSig db 0x7F,'ELF'	; ELF executable signature


EXECUTE:
	; Calculate entry point
	mov ebp, IMAGE_PMODE_BASE
	add ebp, 0x18
	mov ebp, [ebp]

	; set multiboot specs
	mov eax, 0x2BADB002
	mov ebx, 0
	mov edx, [ImageSize]

	; Execute Kernel!
	cli
	push dword boot_info
	call ebp
	add esp, 0x4

;-------------------
; Stop execution
;-------------------
STOP:
	cli			; clear interrupts to prevent triple faults
	hlt			; halt the system
	jmp STOP
