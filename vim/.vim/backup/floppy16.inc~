;=================================================
;	floppy16.inc
;		Floppy drive interface routines
;=================================================

%ifndef __FLOPPY16_INC_INCLUDED__
%define __FLOPPY16_INC_INCLUDED__

bpbOEM			db "AxidOS  "
bpbBytesPerSector:  	DW 512
bpbSectorsPerCluster: 	DB 1
bpbReservedSectors: 	DW 1
bpbNumberOfFATs: 	DB 2
bpbRootEntries: 	DW 224
bpbTotalSectors: 	DW 2880
bpbMedia: 		DB 0xf0  ;; 0xF1
bpbSectorsPerFAT: 	DW 9
bpbSectorsPerTrack: 	DW 18
bpbHeadsPerCylinder: 	DW 2
bpbHiddenSectors: 	DD 0
bpbTotalSectorsBig:     DD 0
bsDriveNumber: 	        DB 0
bsUnused: 		DB 0
bsExtBootSignature: 	DB 0x29
bsSerialNumber:	        DD 0xa0a1a2a3
bsVolumeLabel: 	        DB "MOS FLOPPY "
bsFileSystem: 	        DB "FAT12   "

Datasector  dw 0x0000
Cluster     dw 0x0000

AbsoluteSector db 0x00
AbsoluteHead   db 0x00
AbsoluteTrack  db 0x00

;----------------------------------------------
; Convert CHS to LBA
; LBA = (custer - 2) * sectors per cluster
;----------------------------------------------
CLUSTER2LBA:
	sub ax, 0x0002						; zero base cluster number
	xor cx, cx
	mov cl, BYTE [bpbSectorsPerCluster]	; convert byte to word
	mul cx
	add ax, WORD [Datasector]
	ret

;------------------------------------------------------------------------------
; Convert LBA (Logical Block Address) to CHS (Cylinder/Head/Sector)
; AX => LBA to convert
;
; absolute sector	= (logical sector / sectors per track) + 1
; absolute head		= (logical sector / sectors per track) MOD number of heads
; absolute track	= logical sector / (sectors per track * number of heads)
;------------------------------------------------------------------------------
LBA2CHS:
	xor dx, dx						; prepare DX:AX for operation
	div WORD [bpbSectorsPerTrack]	; calculate
	inc dl							; adjust for sector 0
	mov BYTE [AbsoluteSector], dl
	xor dx, dx						; prepare DX:AX for operation
	div WORD [bpbHeadsPerCylinder]	; calculate
	mov BYTE [AbsoluteHead], dl
	mov BYTE [AbsoluteTrack], al
	ret

;--------------------------------------------
; Reads a series of sectors
; CX		=> number of sectors to read
; AX		=> starting sector
; ES:EBX	=> buffer to reat to
;--------------------------------------------
READ_SECTORS:
	.main:
		mov di, 0x0005					; five retries for error
	.sectorloop:
		push ax
		push bx
		push cx
		call LBA2CHS					; convert starting sector to CHS
		mov ah, 0x02					; BIOS read sector
		mov al, 0x01					; read one sector
		mov ch, BYTE [AbsoluteTrack]	; track
		mov cl, BYTE [AbsoluteSector]	; sector
		mov dh, BYTE [AbsoluteHead]		; head
		mov dl, BYTE [bsDriveNumber]	; drive
		int 0x13						; invoke BIOS
		jnc .success					; test for read error
		xor ax, ax						; BIOS reset disk
		int 0x13						; invoke BIOS
		dec di							; decrement error counter
		pop cx
		pop bx
		pop ax
		jnz .sectorloop					; attempt to read again
		int 0x18
	.success:
		; check if we have buffer segment overflow
		mov ax, WORD [bpbBytesPerSector]; mov the size of sector to AX
		mov cx, 0xFFFF					; mov max WORD value to CX
		sub cx, ax						; set CX to max value before segment overflow to happen
		cmp cx, bx						; compare it with the current segment offset
		jae .no_overflow				; if we haven't reached the max value - do regular routine
		shr bx, 4						; else we end up here. divide current offset by 16
		mov cx, es						; and add the result to the ES (segment register)
		add cx, bx
		mov es, cx
		xor bx, bx						; and reset segment offset to 0
		pop cx							; pop read sector counter
		add sp, 2						; skip the old segment offset (BX), since overflow happened
		pop ax
		jmp .done

	.no_overflow:
		pop cx
		pop bx
		pop ax
	.done:
		add bx, WORD [bpbBytesPerSector]; queue next buffer
		inc ax							; queue next sector
		loop .main						; read next sector
		ret
; Convert CHS to LBA

%endif
