#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <libgen.h>
#include <limits.h>
#include <errno.h>

#define DEPTH_MAX 100

char *_realpath(char *path, char *resolved_path)
{
	int i, error = 0;
	char *tokens[DEPTH_MAX];
	char path_cpy[strlen(path)];
	strcpy(path_cpy, path);

	for (i = 0; i < DEPTH_MAX - 1; ++i)
		tokens[i] = (char *) malloc(PATH_MAX);

	i = 0;
	
	tokens[0] = strtok(path_cpy, "/");
	if (chdir(tokens[0])) {
		/* printf("bad path: %s\n", tokens[0]); */
		/* return NULL; */
		error = 1;
	}
	if (tokens[i] != NULL) {
		while ((tokens[i] = strtok(NULL, "/")) != NULL && !error) {
			if (chdir(tokens[i++])) {
				/* printf("bad path: %s\n", tokens[i-1]); */
				/* return NULL; */
				error = 1;
			}
		}
	}

	/* for (i = 0; i < DEPTH_MAX - 1; ++i) */
	/* 	free(tokens[i]); */

	getcwd(resolved_path, 100);
	/* if last file in path is not a directory,
	 * concatinate it to the return address since it cannot be opened but it belong there
	 */
	if (strstr(path, tokens[i-1]) != NULL) {
		strcat(resolved_path, "/");
		strcat(resolved_path, tokens[i-1]);
	}

	return resolved_path;
}

int main(int argc, char *argv[])
{
	char buf[PATH_MAX];

	if (argc != 2 || strcmp(argv[1], "--help") == 0) {
		printf("Usage: %s path\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	_realpath(argv[1], buf);
	printf("%s\n", buf);

	exit(EXIT_SUCCESS);
}
