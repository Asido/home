#ifndef GUARD_str_h
#define GUARD_str_h

#include <istream>
#include <cstring>
#include <iterator>
#include "vec.h"

class Str {
	friend std::istream& operator>>(std::istream&, Str&);

	public:
		typedef Vec<char>::size_type size_type;
		typedef Vec<char>::iterator iterator;
		typedef Vec<char>::const_iterator const_iterator;
		
		// CONSTRUCTORS
		// default constructor; creates empty Str
		Str() {}
		~Str()
		{
			_data(true);
		}
		// create a Str containing n copies of c
		Str(size_type n, char c):
			data(n, c) {}
		// create a Str from a null-terminated array of char
		Str(const char* cp)
		{
			std::copy(cp, cp + std::strlen(cp), std::back_inserter(data));
		}
		// create a Str from the range denoted by iterators b and e
		// this is a template constructor to make all collection compatible with it
		template<class In> Str(In b, In e)
		{
			data(b, e);
		}

		// OPERATORS
		char& operator[](size_type i)
		{
			return data[i];
		}
		const char& operator[](size_type i) const
		{
			return data[i];
		}

		Str& operator+=(const Str& s)
		{
			std::copy(s.data.begin(), s.data.end(), std::back_inserter(data));
			return *this;
		}

		operator bool()
		{
			return size() != 0;
		}

		// MANIPULATION FUNCTIONS
		template <class I>
		void Insert(I begin, I end)
		{
			while(begin != end)
				data.push_back(*begin++);
		}

		size_type size() const
		{
			return data.size();
		}

		iterator begin()
		{
			return data.begin();
		}
		const_iterator begin() const
		{
			return data.begin();
		}

		iterator end()
		{
			return data.end();
		}
		const_iterator end() const
		{
			return data.end();
		}

		char* c_str();
		char* _data(bool = false);
		void copy(char* p, size_type n);

	private:
		Vec<char> data;
};

std::istream& operator>>(std::istream&, Str&);
std::ostream& operator<<(std::ostream&, const Str&);
Str operator+(const Str& s, const Str& t);
bool operator==(Str& a, Str& b);
bool operator!=(Str& a, Str& b);

std::istream& getline(std::istream&, Str&);

#endif /* end of include guard: GUARD_str_h */
