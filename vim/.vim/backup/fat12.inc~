;===========================================
;	FAT12 filesystem for 3-1/2 floppies
;===========================================

%ifndef __FAT12_INC_INCLUDED_
%define __FAT12_INC_INCLUDED_

[BITS 16]

%include "floppy16.inc"			; floppy driver

%define	ROOT_OFFSET 0x2E00
%define FAT_SEG		0x2C0
%define ROOT_SEG	0x2E0

;--------------------------------------------------------
;	LOAD_ROOT()
;		- load Root Directory Table to 0x7E00
;--------------------------------------------------------
LOAD_ROOT:
	pusha						; store registers
	push es

	; compute size of root directory and store in CX
	xor	cx, cx				; clear registers
	xor	dx, dx
	mov	ax, 32				; 32 byte directory entry
	mul	WORD [bpbRootEntries]	; total size of directory
	div	WORD [bpbBytesPerSector]	; sectors used by directory
	xchg ax, cx				; move into AX

	; compute location of root directory and store in AX
	mov	al, BYTE [bpbNumberOfFATs]	; number of FATs
	mul	WORD [bpbSectorsPerFAT]		; sectors used by FATs
	add	ax, WORD [bpbReservedSectors]
	mov	WORD [Datasector], ax		; base of root directory
	add	WORD [Datasector], cx

	; read root directory into 0x7E00
	push WORD ROOT_SEG
	pop	es
	mov	bx, 0				; copy root dir
	call READ_SECTORS
	pop es
	popa					; restore registers
	ret						; and return

;------------------------------------------
;	LOAD_FAT()
;		- loads FAT table to 0x7C00
;	Param/ ES:DI => Root Directory table
;------------------------------------------
LOAD_FAT:
	pusha				; store registers
	push es

	; compute size of FAT and store in CX
	xor ax, ax
	mov al, BYTE [bpbNumberOfFATs]	; number of FATs
	mul WORD [bpbSectorsPerFAT]		; sectors used by FATs
	mov cx, ax

	; compute location of FAT and store in AX
	mov ax, WORD [bpbReservedSectors]

	; read FAT into memory (overwrite our bootloader at 0x7C00)
	push WORD FAT_SEG
	pop es
	xor bx, bx
	call READ_SECTORS
	pop es
	popa
	ret

;------------------------------------------------------------------------
;	FIND_FILE ()
;		- search for filename in root table
;
;	param/	DS:SI => filename
;	ret/	AX	  => file index number in diretory table. -1 if error
;------------------------------------------------------------------------
FIND_FILE:
	push cx						; store registers
	push dx
	push bx
	mov bx, si					; copy filename for later

	; browse root directory for binary image
	mov cx, WORD [bpbRootEntries]	; load loop counter
	mov di, ROOT_OFFSET				; locate first root entry at 1MB mark
	cld							; clear direction flag

.loop:
	push cx
	mov cx, 11					; 11 character name
	mov si, bx					; image name is in bx
	push di
	rep cmpsb					; test for entry match
	pop di
	je .found
	pop cx
	add di, 32					; queue next directory entry
	loop .loop

.not_found:
	pop bx						; restore registers and return
	pop dx
	pop cx
	mov ax, -1					; set error code
	ret

.found:
	pop ax						; return value into AX contains entry of file
	pop bx						; restore registers and return
	pop dx
	pop cx
	ret

;------------------------------------------------
;	LOAD_FILE()
;		- load file
;	param/	ES:SI	=> File to load
;	param/	EBX:BP	=> Buffer to load file to
;
;	ret/	AX => -1 on error, 0 on success
;	ret/	CX => number of sectors read
;------------------------------------------------
LOAD_FILE:
	xor ecx, ecx			; size of file in sectors
	push ecx

.find_file:
	push bx					; BX=>BP points to buffer to write to; store it for later
	push bp
	call FIND_FILE			; find our file. ES:SI contains our filename
	cmp ax, -1
	jne .load_image_pre
	pop bp
	pop bx
	pop ecx
	mov ax, -1
	ret

.load_image_pre:
	sub edi, ROOT_OFFSET
	sub eax, ROOT_OFFSET

	; get starting cluster
	push WORD ROOT_SEG	; root segment loc
	pop es
	mov dx, WORD [es:di + 0x001A]	; DI points to file entry in root directory table. reference the table...
	mov WORD [Cluster], dx	; file's first cluster
	pop bx					; get location to write to so we don't screw up the stack
	pop es
	push bx					; store location for later again
	push es
	call LOAD_FAT

.load_image:
	; load the cluster
	mov ax, WORD [Cluster]	; cluster to read
	pop es					; BX:BP = ES:BX
	pop bx
	call CLUSTER2LBA
	xor cx, cx
	mov cl, BYTE [bpbSectorsPerCluster]
	call READ_SECTORS
	pop ecx
	inc ecx					; add one more sector to counter
	push ecx
	push bx
	push es
	mov ax, FAT_SEG			; start reading from fat
	mov es, ax
	xor bx, bx

	; get next cluster
	mov ax, WORD [Cluster]	; identify current cluster
	mov cx, ax				; copy current cluster
	mov dx, ax
	shr dx, 0x0001			; divide by two
	add cx, dx				; sum for (3/2)

	mov bx, 0				; location of FAT in memory
	add bx, cx
	mov dx, WORD [es:bx]
	test ax, 0x0001			; test for odd or even cluster
	jnz .odd_cluster

.even_cluster:
	and dx, 0000111111111111b	; take low 12 bits
	jmp .done

.odd_cluster:
	shr dx, 0x0004			; take high 12 bits

.done:
	mov WORD [Cluster], dx
	cmp dx, 0x0FF0			; test for end of file marker
	jb .load_image
;	cmp cx, 165
;	jnz .load_image

.success:
	pop es
	pop bx
	pop ecx
	xor ax, ax
	ret

%endif
