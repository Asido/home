#include <stdio.h>
#include <hal.h>
#include <exception.h>
#include <pmm.h>
#include <vmm.h>
#include <bootinfo.h>
#include <keyboard.h>

/*
*	Our uber-1337 logo
*/
char* logo =
"\
    ___              ____   ____\n\
   /   |_  _  __    / __ \\/ ___/\n\
  / /| |\\\\//||--\\\\ / / / /\\__ \\ The Worst Operating System\n\
 / /_| | \\\\ |||_||/ /_/ /___/ / -----------------------------\n\
/_/  |_|//\\\\||__//\\____/\\____/  \n\n";

// format of a memory region
struct memory_region {
	uint32_t	startLo;
	uint32_t	startHi;
	uint32_t	sizeLo;
	uint32_t	sizeHi;
	uint32_t	type;
	uint32_t	acpi_3_0;
};

// different memory regions (in memory_region.type)
char *strMemoryTypes[] = {
	"Available",			//memory_region.type == 0
	"Reserved",				//memory_region.type == 1
	"ACPI Reclaim",			//memory_region.type == 2
	"ACPI NVS Memory"		//memory_region.type == 3
};

static uint32_t kernel_size = 0;

void init(struct multiboot_info *bootinfo)
{
	set_color(0xF, 0x9);
	clear_screen();

	// Initialize HAL driver
	hal_initialize();

	// enable all interrupts
	enable();

	// install our exception handlers
	setvect(0,divide_by_zero_fault);
	setvect(1,single_step_trap);
	setvect(2,nmi_trap);
	setvect(3,breakpoint_trap);
	setvect(4,overflow_trap);
	setvect(5,bounds_check_fault);
	setvect(6,invalid_opcode_fault);
	setvect(7,no_device_fault);
	setvect(8,double_fault_abort);
	setvect(10,invalid_tss_fault);
	setvect(11,no_segment_fault);
	setvect(12,stack_fault);
	setvect(13,general_protection_fault);
	setvect(14,page_fault);
	setvect(16,fpu_fault);
	setvect(17,alignment_check_fault);
	setvect(18,machine_check_abort);
	setvect(19,simd_fpu_fault);

	pmm_init(bootinfo->m_memorySize, 0xC0000000 + kernel_size*512);

	struct memory_region *region = (struct memory_region *) 0x1000;

	int i;
	for (i = 0; i < 10; ++i) {
		if (region[i].type > 4)
			break;

		if (i > 0 && region[i].startLo == 0)
			break;

		pmm_init_region(region[i].startLo, region[i].sizeLo);
	}
	pmm_deinit_region(0x100000, kernel_size * 512);

	// initialize vmm
	vmm_initialize();

	// install the keyboard to IR 33
	kkybrd_install(33);

	// set drive 0 as current drive
	flpydsk_set_working_drive(0);
	// install floppy disk to IR 38, uses IRQ 6
	flpydsk_install(38);
}

// sleeps a little bit. This uses the HALs get_tick_count() which in turn uses the PIT
void sleep(int ms)
{
	int ticks = ms + get_tick_count();
	while (ticks > get_tick_count())
		;
}

// wait for key stroke
enum KEYCODE getch()
{
	enum KEYCODE key = KEY_UNKNOWN;

	// wait for a keypress
	while (key == KEY_UNKNOWN)
		key = kkybrd_get_last_key();

	// discard last keypress (we handled it) and return
	kkybrd_discard_last_key();
	return key;
}

// command prompt
void cmd()
{
	printf("\nCommand> ");
}

// gets next command
void get_cmd(char *buf, int n)
{
	cmd();

	enum KEYCODE key = KEY_UNKNOWN;
	bool BufChar;

	// get command string
	int i = 0;
	while (i < n) {
		// buffer the next char
		BufChar = true;

		// grab next char
		key = getch();

		// end of command if enter is pressed
		if (key == KEY_RETURN)
			break;

		// backspace
		if (key == KEY_BACKSPACE) {
			// dont buffer this char
			BufChar = false;

			if (i > 0) {

				// go back one char
				unsigned y, x;
				get_xy(&x, &y);
				if (x > 0)
					goto_xy(--x, y);
				else {
					// x is already 0, so go back one line
					y--;
					x = get_screen_width();
				}

				// erase the character from display
				putchar(' ');
				goto_xy(x, y);

				// go back one char in cmd buf
				i--;
			}
		}

		// only add the char if it is to be buffered
		if (BufChar) {
			// convert key to an ascii char and put it in buffer
			char c = kkybrd_key_to_ascii(key);
			if (c != 0) { //insure its an ascii char
				putchar(c);
				buf[i++] = c;
			}
		}

		// wait for next key. You may need to adjust this to suite your needs
		sleep(10);
	}

	// null terminate the string
	buf[i] = '\0';
}

// command parser
bool run_cmd(char *cmd_buf)
{
	if (strcmp(cmd_buf, "exit") == 0) {			// exit
		return true;
	} else if (strcmp(cmd_buf, "cls") == 0) {	// clear screen
		clear_screen();
	} else if (strcmp(cmd_buf, "help") == 0) {	// help
		puts("Supported commands:\n");
		puts(" - exit: quits and halts the system\n");
		puts(" - cls: clears the display\n");
		puts(" - help: displays this message\n");
	} else {	// invalid command
		printf("\nUnkown command");
	}

	return false;
}

void run () {
	// command buffer
	char cmd_buf[100];

	while (1) {
		// get command
		get_cmd(cmd_buf, 98);

		// run command
		if (run_cmd(cmd_buf) == true)
			break;
	}
}

// read sector command
void cmd_read_sect()
{
	uint32_t sectornum = 0;
	char sectornumbuf[4];
	uint8_t* sector = 0;

	printf("\n\rPlease type in the sector number [0 is default] >");
	get_cmd(sectornumbuf, 3);
	sectornum = atoi(sectornumbuf);

	printf("\n\rSector %i contents:\n\n\r", sectornum);

	// read sector from disk
	sector = flpydsk_read_sector(sectornum);

	//! display sector
	if (sector != 0) {
		int i = 0;
		int c;
		for (c = 0; c < 4; c++) {
			int j;
			for (j = 0; j < 128; j++)
				printf("0x%x ", sector[i+j]);
			i += 128;

			printf("\n\rPress any key to continue\n\r");
			getch();
		}
	} else
		printf("\n\r*** Error reading sector from disk");

	printf("\n\rDone.");
}

int kmain(struct multiboot_info *bootinfo)
{
	asm(".intel_syntax noprefix\n");
	asm("cli\n");						// clear interrupts--Do not enable them yet
	asm("mov eax, 0x10\n");				// offset 0x10 in gdt for data selector
	asm("mov ds, ax\n");
	asm("mov es, ax\n");
	asm("mov fs, ax\n");
	asm("mov gs, ax\n");

	// get kernel size passed from bootloader
	asm("mov word ptr [kernel_size], dx\n");
	kernel_size = 85956/512+1;

	init(bootinfo); 

	// render text and logo
	goto_xy(0,0);
	puts(logo);

	run();

	printf("\nExit command recieved.");
	for (;;);
	return 0;
}
