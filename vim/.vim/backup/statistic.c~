#define _XOPEN_SOURCE 500
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ftw.h>
#include <dirent.h>
#include <errno.h>

int total_files = 0;
int reg = 0;
int dirs = 0;
int symlinks = 0;

char *inode_to_fname(char *folder, ino_t inode, char *buf)
{
	DIR *fd;
	struct dirent *dir;

	if ((fd = opendir(folder)) == NULL)
		printf("ERROR: opendir");

	errno = 0;
	while ((dir = readdir(fd)) != NULL) {
		if (dir->d_ino == inode) {
			strcpy(buf, dir->d_name);
			return buf;
		}
	}
	if (errno != 0)
		printf("ERROR: inode_to_fname");
	return buf;
}

void print_statistic(void)
{
	printf("Total files: %d\n", total_files);
	if (total_files > 0) {
		printf("Directories: %d (%d%)\n", dirs, (100 / total_files * dirs));
		printf("Regular files: %d (%d%)\n", reg, (100 / total_files * reg));
		printf("Symbolic links: %d (%d%)\n", symlinks, (100 / total_files * symlinks));
	}
}

int register_statistic(const char *path, const struct stat *sb, int tflag, struct FTW *ftwbuf)
{
	char filename[FILENAME_MAX];
	if (strcmp(inode_to_fname(".", sb->st_ino, filename), ".") == 0)
		return 0;

	++total_files;
	if (sb->st_mode & S_IFDIR) {
		++dirs;
		return 0;
	} else if (sb->st_mode & S_IFREG) {
		++reg;
		return 0;
	} else if (sb->st_mode & S_IFLNK) {
		++symlinks;
		return 0;
	} else 
		return -1;
}

int main(int argc, char *argv[])
{
	int flags = 0;
	flags |= FTW_D;
	if (nftw((argc == 2) ? argv[1] : ".", register_statistic, 50, flags) != 0)
		printf("ERROR: nftw");
	print_statistic();

	exit(EXIT_SUCCESS);
}
