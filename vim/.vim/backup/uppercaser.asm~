;	Description:
;		Converts input lower-case letters to upper-case.
;
;	Run:
;		./uppercaser > (output file) < (input file)
;
;	Build:
;		nasm -f elf -g -F stabs uppercaser.asm
;		ld -o uppercaser uppercaser.o

SECTION .data				; Section containing initialised data

SECTION .bss				; Section containing uninitialised data
	BUFFLEN equ 1024		; Length of buffer constant
	Buff:	resb BUFFLEN	; Text buffer itself

SECTION .text				; Section containing code
	global _start			; Linker needs this to find the entry point
	_start:
		nop					; To keep gdb happy

	; Read a buffer full of text from stdin:
	read:
		mov eax, 3			; Specify sys_read call
		mov ebx, 0			; Specify File Descriptor 0: Standard Input
		mov ecx, Buff		; Pass offset of the buffer to read to
		mov edx, BUFFLEN	; Pass number of bytes to read at one pass
		int 0x80			; Call sys_read to fill the buffer
		mov esi, eax		; Copy sys_read return value for safekeeping
		cmp eax, 0			; If eax = 0, sys_read reached EOF on stdin
		je done				; Jump If Equal (to 0, from compare)

	; Set up registers for the process buffer step:
		mov ecx, esi		; Place the number of bytes read into ecx
		mov ebp, Buff		; Place address of buffer into ebp
		dec ebp				; Adjust count to offset

	; Go through the buffer and convert lowercase to uppercase characters:
	scan:
		cmp byte [ebp+ecx], 61h	; Test input char against lowercase 'a'
		jb next				; If below 'a' in ASCII, not lowercase
		cmp byte [ebp+ecx], 7ah	; Test input char against lowercase 'z'
		ja Next				; If above 'z' in ASCII, not lowercase
							; At this point, we have a lowercase char
		sub byte [ebp+ecx], 20h	; Subtract 20h to give uppercase...
	next:
		dec ecx				; Decrement counter
		jnz scan			; If characters remain, loop back

	; Write the buffer full of processed text to stdout:
	write:
		mov eax, 4			; Specify sys_write call
		mov ebx, 1			; Specify File Descriptor 1: Standard output
		mov ecx, Buff		; Pass offset of the buffer
		mov edx, esi		; Pass the # of bytes of data in the buffer
		int 0x80			; Make sys_write kernel call
		jmp read			; Loop back and load another buffer full

	; All done! Now clean exit:
	done:
		mov eax, 1			; Code for Exit Syscall
		mov ebx, 0			; Return a code of zero
		int 0x80			; Make sys_exit kernel call
